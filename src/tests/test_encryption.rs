use super::*;
#[cfg(test)]
use rand::Rng;
use std::fs::OpenOptions;
use std::io::Write;

// this function takes as input a message m and returns its size in bits

fn message_size(m: i64) -> usize {
    if m >= 0 {
        let m_bin = format!("{:b}", m);
        return m_bin.to_string().len();
    } else {
        let m_abs = m.abs();
        let m_abs_bin = format!("{:b}", m_abs);
        return m_abs_bin.to_string().len() + 1;
    }
}

// In this function we encrypt an integer m than decrypt it and compare the result with the input value m
// we save the result of tests into specific files related to each test

fn test_encrypt_decrypt_m(m: i64, filename: &str) -> Result<(), Box<dyn Error>> {
    // =================================
    //  Initialization

    // ---------------------------------
    //  Global Scope
    let par = &params::PARM90__PI_5__D_20__LEN_32; //     PARM90__PI_5__D_20__LEN_32      PARMXX__TRIVIAL

    // ---------------------------------
    //  Userovo Scope
    let pu = ParmesanUserovo::new(par)?;

    // we encrypt m with a number of encrypted bits = message_size than decrypt to compare the result to the input value

    let nb_enc_bits = message_size(m);
    let enc_m = pu.encrypt(m, nb_enc_bits)?;
    let res: i64 = pu.decrypt(&enc_m)?;
    let res_len = message_size(res);
    if m == res {
        println!(
            "test status: valid, sample : {} , decrypted result : {} , number of encrypted bits (input size) : {}, length of decrypted result : {} ",
            m, res, nb_enc_bits, res_len
        );

        // if the test succeeds , we write the test result into a file "filename_samples.txt"

        let line = "test: encryption, status : valid, sample : ".to_owned()
            + &m.to_string()
            + ", decrypted result : "
            + &res.to_string()
            + ", number of encrypted bits(input size) : "
            + &nb_enc_bits.to_string()
            + ", length of decrypted result :"
            + &res_len.to_string()
            + "\n";
        let mut enc_message = OpenOptions::new()
            .read(true)
            .append(true)
            .create(true)
            .open("src/tests/test_history/".to_owned() + filename + "_samples.txt")
            .unwrap();
        enc_message.write_all(line.as_bytes())?;
    } else {
        println!(
                "test status: failure , sample : {} , decrypted result : {} , number of encrypted bits (input size) {}, decrypted result: length{} ",
                m, res, nb_enc_bits, res_len
            );

        // if the test fails, we write the test result into a file "filename_failures.txt"

        let line = "test: encryption, status : failur, sample : ".to_owned()
            + &m.to_string()
            + ", decrypted result : "
            + &res.to_string()
            + ", number of encrypted bits(input size) : "
            + &nb_enc_bits.to_string()
            + ", length of decrypted result :"
            + &res_len.to_string()
            + "\n";
        let mut enc_message = OpenOptions::new()
            .read(true)
            .append(true)
            .create(true)
            .open("src/tests/test_history/".to_owned() + filename + "_failures.txt")
            .unwrap();
        enc_message.write_all(line.as_bytes())?;
    }
    assert_eq!(res, m);
    Ok(())
}

#[test]
// In this test we encrypt and decrypt specific values we give as input

fn encrypt_decrypt_m() {
    let filename = "enc_message";
    test_encrypt_decrypt_m(-1008599095, filename).unwrap();
}

#[test]
// in this test we generate random positive values and call test_encrypt_decrypt_m to test them
fn encrypt_decrypt_positive() {
    let filename = "enc_positive";
    let mut rng = rand::thread_rng();
    let mut m1: i64;
    for _i in 0..10 {
        m1 = rng.gen_range(0..i64::max_value());
        test_encrypt_decrypt_m(m1, filename).unwrap();
    }
}

#[test]
// in this test we generate random negative values and call test_encrypt_decrypt_m to test them
fn encrypt_decrypt_negative() {
    let filename = "enc_negative";
    let mut rng = rand::thread_rng();
    let mut m1: i64;
    for _i in 0..10 {
        m1 = rng.gen_range(i64::min_value()..0);
        test_encrypt_decrypt_m(m1, filename).unwrap();
    }
}

#[test]
// in this test we generate random ( positive or negative ) values and call test_encrypt_decrypt_m to test them
fn encrypt_decrypt_rd() {
    let filename = "enc_rand";
    let mut rng = rand::thread_rng();
    let mut m1: i64;
    for _i in 0..10 {
        m1 = rng.gen::<i64>();
        test_encrypt_decrypt_m(m1, filename).unwrap();
    }
}
#[test]
// This test is specifically related to a failure we found in scalar multiplication
// we try to decrypt a trivial ciphertext generated by ParmCiphertext
fn decrypt_triv() -> Result<(), Box<dyn Error>> {
    // =================================
    //  Initialization

    // ---------------------------------
    //  Global Scope
    let par = &params::PARM90__PI_5__D_20__LEN_32; //     PARM90__PI_5__D_20__LEN_32      PARMXX__TRIVIAL

    // ---------------------------------
    //  Userovo Scope
    let pu = ParmesanUserovo::new(par)?;

    // generate a ciphertext trivial 1
    let enc_r1 = ParmCiphertext::triv(1)?;

    // decrypt the generated ciphertext
    let dec_r1: i64 = pu.decrypt(&enc_r1)?;
    assert_eq!(dec_r1, 0);
    Ok(())
}
